# CLAUDE.md - Scan & Speak Multilingual Shopping Assistant

## üéØ ROLE DEFINITION

You are a **Senior Full-Stack Engineer** and **AI Integration Specialist** with deep expertise in:
- Next.js 15 + TypeScript + App Router architecture
- Real-time multilingual voice processing (100+ languages)
- OpenAI API integration with streaming responses
- AssemblyAI speech-to-text with language auto-detection
- Production-ready error handling and edge case management
- Accessibility-first development (WCAG 2.1 AA compliance)

**Your mission**: Build a flawless multilingual shopping assistant that automatically detects user language (spoken or typed) and responds naturally in that same language, with zero manual language selection required.

## üèóÔ∏è PROJECT CONTEXT

<project_overview>
**Application**: Scan & Speak - Multilingual Shopping Assistant
**Core Value Proposition**: Transform any device into a universal shopping assistant that works in 100+ languages automatically
**Target Users**: International shoppers, accessibility users, busy parents
**Success Metrics**: 95% language detection accuracy, <500ms response time, zero friction UX
</project_overview>

<technical_stack>
**Primary Stack**:
- **Frontend**: Next.js 15 + TypeScript + Tailwind CSS + shadcn/ui
- **AI Integration**: OpenAI GPT-4o-mini with streaming responses
- **Voice Processing**: OpenAI Whisper (speech-to-text) + OpenAI TTS (text-to-speech) with cross-browser MediaRecorder compatibility
- **Language Detection**: OpenAI Whisper built-in + enhanced pattern matching (40+ languages)
- **State Management**: React hooks + Context for minimal complexity
- **Database**: Local JSON catalog with fuzzy search (Fuse.js)
- **Deployment**: Vercel (production-ready)
</technical_stack>

<api_credentials>
**CRITICAL: Set up your OpenAI API key in environment variables**
```typescript
// Environment Configuration (.env.local)
OPENAI_API_KEY=your_openai_api_key_here

// In your API routes, use environment variables:
const OPENAI_KEY = process.env.OPENAI_API_KEY;

// OpenAI Services Available:
// - Chat: gpt-4o-mini (fast, cost-effective)
// - Speech-to-Text: whisper-1 (100+ languages)
// - Text-to-Speech: tts-1 (natural voices)
// - Advanced Audio: gpt-4o-audio-preview (if needed)
```
</api_credentials>

## üéØ CRITICAL IMPLEMENTATION REQUIREMENTS

<core_functionality>
**PRIMARY REQUIREMENTS - MUST BE PERFECT**:
1. **Language Auto-Detection**: Detect language from text/speech input automatically
2. **Same-Language Response**: AI responds in exact same language as user input
3. **Voice Recognition**: AssemblyAI + Web Speech API fallback
4. **Chat Streaming**: Real-time typewriter effect with OpenAI streaming
5. **Product Search**: Fuzzy search through local product catalog
6. **Zero Language Selection**: No manual language pickers anywhere
7. **Mobile-First**: Perfect experience on all devices
8. **Error Resilience**: Graceful handling of all failure scenarios
</core_functionality>

<architecture_patterns>
**ARCHITECTURE REQUIREMENTS**:
```
User Input (Text/Voice) ‚Üí OpenAI Processing ‚Üí Streaming Response

Text Flow:
‚îú‚îÄ‚îÄ User Types ‚Üí Auto-Detect Language ‚Üí OpenAI Chat ‚Üí Stream Response

Voice Flow:
‚îú‚îÄ‚îÄ User Speaks ‚Üí OpenAI Whisper ‚Üí Language Auto-Detected ‚Üí OpenAI Chat ‚Üí OpenAI TTS ‚Üí Audio Response
‚îî‚îÄ‚îÄ Fallback: Web Speech API ‚Üí Language Detection ‚Üí OpenAI Chat ‚Üí Browser TTS
```
</architecture_patterns>

<performance_standards>
**PERFORMANCE REQUIREMENTS**:
- **Response Time**: <500ms for text, <2s for voice
- **Language Detection**: >95% accuracy for supported languages
- **Voice Recognition**: >90% accuracy for clear speech
- **Streaming**: 30ms per character typewriter effect
- **Mobile Performance**: Smooth on 3G networks
- **Accessibility**: Screen reader compatible, keyboard navigation
</performance_standards>

## üö® CRITICAL PROBLEMS TO SOLVE

<current_issues>
**IMMEDIATE BLOCKERS** (Must fix before any other work):

1. **Chat API Not Connected**
   - Problem: Frontend not connecting to OpenAI API
   - Symptoms: Random responses, no actual AI processing
   - Required Fix: Complete /api/chat/route.ts implementation

2. **Language Detection Broken**
   - Problem: Responses in random languages (English/Spanish/French mix)
   - Symptoms: User speaks Spanish, gets English response
   - Required Fix: Automatic language detection + forced same-language response

3. **Voice Recognition Failure**
   - Problem: "Failed to process your request" errors
   - Symptoms: Audio processing not working, no speech transcription
   - Required Fix: Complete OpenAI Whisper integration with Web Speech API fallback

4. **Manual Language Selector Present**
   - Problem: Language picker defeats the app's core purpose
   - Symptoms: Users can manually select language
   - Required Fix: Remove all manual language selection UI
</current_issues>

<zero_tolerance_requirements>
**THESE ARE COMPLETELY UNACCEPTABLE**:
- ‚ùå Partial implementations or "mostly working" features
- ‚ùå Manual language selection anywhere in the UI
- ‚ùå Responses in different language than user input
- ‚ùå Non-functional voice recognition
- ‚ùå API errors without proper user feedback
- ‚ùå Any "TODO" or "Coming soon" placeholders
- ‚ùå Broken mobile experience
- ‚ùå Accessibility violations
</zero_tolerance_requirements>

## üìã STEP-BY-STEP IMPLEMENTATION PROTOCOL

<implementation_phases>
**PHASE 1: API Foundation (Priority 1)**
```markdown
OBJECTIVE: Get OpenAI chat working with language detection

TASKS:
1. Create /api/chat/route.ts with exact API key
2. Implement language detection function
3. Create system prompt that enforces same-language response
4. Test with: English, Spanish, French inputs
5. Validate API returns proper JSON structure

SUCCESS CRITERIA:
‚úÖ POST to /api/chat returns 200 status
‚úÖ English input ‚Üí English response
‚úÖ Spanish input ‚Üí Spanish response  
‚úÖ French input ‚Üí French response
‚úÖ Network tab shows successful API calls
```

**PHASE 2: Frontend Integration (Priority 2)**
```markdown
OBJECTIVE: Connect chat UI to working API

TASKS:
1. Create ChatInterface component with proper state management
2. Implement streaming response with typewriter effect
3. Add loading states and error handling
4. Style message bubbles with language indicators
5. Test end-to-end chat flow

SUCCESS CRITERIA:
‚úÖ User can type message and see response
‚úÖ Streaming typewriter effect works smoothly
‚úÖ Language tags show on messages
‚úÖ Error states display user-friendly messages
‚úÖ Mobile responsive design works perfectly
```

**PHASE 3: Voice Recognition (Priority 3)**
```markdown
OBJECTIVE: Complete voice processing pipeline with comprehensive error handling

TASKS:
1. Implement VoiceRecognitionManager class with robust error handling
2. Create three-tier fallback system: OpenAI Whisper ‚Üí Web Speech API ‚Üí Manual Input
3. Handle all voice recognition errors gracefully (service-not-allowed, permissions, etc.)
4. Add proper microphone permission handling and user feedback
5. Test across different browsers and error scenarios

SUCCESS CRITERIA:
‚úÖ Primary: OpenAI Whisper transcribes speech accurately with language auto-detection
‚úÖ Fallback 1: Web Speech API works when Whisper fails (with HTTPS requirement)
‚úÖ Fallback 2: Manual input prompt when both voice methods fail
‚úÖ Error Handling: All voice errors show user-friendly messages with retry options
‚úÖ Cross-Browser: Works on Chrome, Safari, Firefox, Edge with proper MIME type fallbacks
‚úÖ Permissions: Handles microphone access denial gracefully
‚úÖ Network: Handles API failures and timeouts properly
```

**PHASE 4: Polish & Production (Priority 4)**
```markdown
OBJECTIVE: Production-ready experience

TASKS:
1. Remove any remaining language selection UI
2. Optimize performance and error handling
3. Add comprehensive accessibility features
4. Implement proper SEO and metadata
5. Test exhaustively across devices/browsers

SUCCESS CRITERIA:
‚úÖ Zero manual language selection anywhere
‚úÖ Perfect mobile experience
‚úÖ Screen reader accessibility
‚úÖ Fast performance on slow networks
‚úÖ Professional, polished UI
```
</implementation_phases>

## üîß EXACT IMPLEMENTATION SPECIFICATIONS

<language_detection_implementation>
**Enhanced Language Detection Algorithm (Supports 40+ Languages)**:
```typescript
// EXACT IMPLEMENTATION REQUIRED - Handles all major world scripts
function detectLanguage(text: string): string {
  const cleanText = text.toLowerCase().trim();
  
  // Unicode script detection (most reliable for non-Latin)
  const scriptPatterns = {
    // East Asian Scripts
    'zh': /[\u4e00-\u9fff]/,          // Chinese (CJK Unified Ideographs)
    'ja': /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/, // Japanese (Hiragana + Katakana + Kanji)
    'ko': /[\uac00-\ud7af\u1100-\u11ff\u3130-\u318f]/, // Korean (Hangul)
    
    // Middle Eastern Scripts  
    'ar': /[\u0600-\u06ff\u0750-\u077f]/,  // Arabic + Arabic Supplement
    'fa': /[\u0600-\u06ff\u0750-\u077f]/,  // Persian (uses Arabic script)
    'ur': /[\u0600-\u06ff\u0750-\u077f]/,  // Urdu (uses Arabic script)
    'he': /[\u0590-\u05ff]/,              // Hebrew
    
    // Indian Subcontinent Scripts
    'hi': /[\u0900-\u097f]/,              // Hindi (Devanagari)
    'bn': /[\u0980-\u09ff]/,              // Bengali
    'gu': /[\u0a80-\u0aff]/,              // Gujarati
    'ta': /[\u0b80-\u0bff]/,              // Tamil
    'te': /[\u0c00-\u0c7f]/,              // Telugu
    'th': /[\u0e00-\u0e7f]/,              // Thai
    
    // Other Scripts
    'ru': /[\u0400-\u04ff]/,              // Cyrillic (Russian, etc.)
    'el': /[\u0370-\u03ff]/,              // Greek
    'ka': /[\u10a0-\u10ff]/,              // Georgian
    'hy': /[\u0530-\u058f]/,              // Armenian
  };
  
  // Check script patterns first (most reliable for non-Latin)
  for (const [lang, pattern] of Object.entries(scriptPatterns)) {
    if (pattern.test(text)) {
      return lang;
    }
  }
  
  // Enhanced Latin script detection
  const latinPatterns = {
    'es': /\b(d√≥nde|est√°|cu√°nto|cuesta|precio|ubicaci√≥n|pasillo|¬ø|¬°|el|la|los|las|qu√©|c√≥mo|cu√°ndo|gracias|hola)\b/i,
    'fr': /\b(o√π|est|combien|co√ªte|prix|emplacement|all√©e|le|la|les|que|comment|quand|merci|bonjour|√ß|√†|√®|√©)\b/i,
    'de': /\b(wo|ist|wieviel|kostet|preis|standort|gang|der|die|das|wie|wann|was|danke|hallo|√§|√∂|√º|√ü)\b/i,
    'it': /\b(dove|√®|quanto|costa|prezzo|posizione|corridoio|il|la|i|le|che|come|quando|grazie|ciao)\b/i,
    'pt': /\b(onde|est√°|quanto|custa|pre√ßo|localiza√ß√£o|corredor|o|a|os|as|que|como|quando|obrigado|ol√°|√£|√µ)\b/i,
    'pl': /\b(gdzie|jest|ile|kosztuje|cena|jak|kiedy|co|dziƒôkujƒô|cze≈õƒá|ƒÖ|ƒá|ƒô|≈Ç|≈Ñ|√≥|≈õ|≈∫|≈º)\b/i,
    'nl': /\b(waar|is|hoeveel|kost|prijs|hoe|wanneer|wat|dank je|hallo)\b/i,
    'sv': /\b(var|√§r|hur mycket|kostar|pris|hur|n√§r|vad|tack|hej|√•|√§|√∂)\b/i,
  };
  
  // Check Latin script patterns
  for (const [lang, pattern] of Object.entries(latinPatterns)) {
    if (pattern.test(cleanText)) {
      return lang;
    }
  }
  
  return 'en'; // Default fallback
}
```
</language_detection_implementation>

<system_prompt_template>
**OpenAI System Prompt (CRITICAL - Use Exactly)**:
```typescript
function createSystemPrompt(detectedLanguage: string, catalogData: string): string {
  const languageNames = {
    // Latin Script Languages
    'en': 'English', 'es': 'Spanish', 'fr': 'French', 'de': 'German',
    'it': 'Italian', 'pt': 'Portuguese', 'nl': 'Dutch', 'sv': 'Swedish',
    'no': 'Norwegian', 'da': 'Danish', 'pl': 'Polish', 'cs': 'Czech',
    'sk': 'Slovak', 'hr': 'Croatian', 'sl': 'Slovenian', 'ro': 'Romanian',
    'fi': 'Finnish', 'hu': 'Hungarian',
    
    // Non-Latin Script Languages
    'zh': 'Chinese', 'ja': 'Japanese', 'ko': 'Korean',
    'ar': 'Arabic', 'fa': 'Persian', 'ur': 'Urdu', 'he': 'Hebrew',
    'hi': 'Hindi', 'bn': 'Bengali', 'gu': 'Gujarati', 'pa': 'Punjabi',
    'ta': 'Tamil', 'te': 'Telugu', 'kn': 'Kannada', 'ml': 'Malayalam',
    'th': 'Thai', 'lo': 'Lao', 'my': 'Myanmar', 'km': 'Khmer',
    'ru': 'Russian', 'uk': 'Ukrainian', 'bg': 'Bulgarian', 'sr': 'Serbian',
    'el': 'Greek', 'ka': 'Georgian', 'hy': 'Armenian'
  };
  
  const langName = languageNames[detectedLanguage] || 'English';
  
  return `You MUST respond entirely in ${langName}. Never use any other language in your response.

CRITICAL: If the user writes in ${langName}, you must respond in ${langName} using the proper script/alphabet for that language.

You are Scan & Speak, a helpful multilingual shopping assistant. Your job is to help customers find products in stores.

CRITICAL RULES:
1. Respond ONLY in ${langName} language using its native script
2. If you detect the user is asking about products, search the catalog and provide specific details
3. Include product location (aisle/section) and price when available
4. If a product is not found, say exactly: "I couldn't find that product in our store database" (translated to ${langName})
5. For non-shopping questions, politely redirect to product inquiries in ${langName}

Product Catalog:
${catalogData}

Remember: Every word in your response must be in ${langName} using the correct alphabet/script for that language.`;
}
```
</system_prompt_template>

<file_structure_requirements>
**REQUIRED FILE STRUCTURE**:
```
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx          # Root layout with SINGLE navigation
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx            # Landing page
‚îÇ   ‚îú‚îÄ‚îÄ chat/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx        # Chat interface page
‚îÇ   ‚îú‚îÄ‚îÄ voice/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx        # Voice interface page
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îú‚îÄ‚îÄ chat/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ route.ts    # OpenAI streaming chat endpoint
‚îÇ       ‚îú‚îÄ‚îÄ speech/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ route.ts    # OpenAI Whisper speech-to-text
‚îÇ       ‚îî‚îÄ‚îÄ tts/
‚îÇ           ‚îî‚îÄ‚îÄ route.ts    # OpenAI text-to-speech
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface.tsx   # Complete chat component
‚îÇ   ‚îú‚îÄ‚îÄ VoiceInterface.tsx  # Complete voice component
‚îÇ   ‚îî‚îÄ‚îÄ Navigation.tsx      # Single navigation component
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ openai.ts          # OpenAI client config (chat + whisper + tts)
‚îÇ   ‚îú‚îÄ‚îÄ whisper.ts         # OpenAI Whisper speech-to-text
‚îÇ   ‚îú‚îÄ‚îÄ tts.ts             # OpenAI text-to-speech
‚îÇ   ‚îú‚îÄ‚îÄ language-detection.ts # Language detection logic
‚îÇ   ‚îî‚îÄ‚îÄ product-catalog.ts # Product search functionality
‚îî‚îÄ‚îÄ data/
    ‚îî‚îÄ‚îÄ products.json      # Product database
```
</file_structure_requirements>

## üß™ COMPREHENSIVE TESTING PROTOCOL

<testing_scenarios>
**MANDATORY TEST CASES** (Must pass before deployment):

**Language Detection Tests**:
```
1. English: "Where can I find milk?" ‚Üí Detect 'en' ‚Üí English response
2. Spanish: "¬øD√≥nde est√° la leche?" ‚Üí Detect 'es' ‚Üí Spanish response
3. French: "O√π est le lait?" ‚Üí Detect 'fr' ‚Üí French response
4. German: "Wo ist die Milch?" ‚Üí Detect 'de' ‚Üí German response
5. Chinese: "‰Ω†Â•ΩÔºåÊàëÂú®Âì™ÈáåÂèØ‰ª•ÊâæÂà∞ÁâõÂ•∂Ôºü" ‚Üí Detect 'zh' ‚Üí Chinese response
6. Arabic: "ŸÖÿ±ÿ≠ÿ®ÿßÿå ÿ£ŸäŸÜ ŸäŸÖŸÉŸÜŸÜŸä ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿ≠ŸÑŸäÿ®ÿü" ‚Üí Detect 'ar' ‚Üí Arabic response  
7. Japanese: "„Åì„Çì„Å´„Å°„ÅØ„ÄÅÁâõ‰π≥„ÅØ„Å©„Åì„ÅßË¶ã„Å§„Åë„Çâ„Çå„Åæ„Åô„ÅãÔºü" ‚Üí Detect 'ja' ‚Üí Japanese response
8. Korean: "ÏïàÎÖïÌïòÏÑ∏Ïöî, Ïö∞Ïú†Îäî Ïñ¥ÎîîÏÑú Ï∞æÏùÑ Ïàò ÏûàÎÇòÏöîÔºü" ‚Üí Detect 'ko' ‚Üí Korean response
9. Hindi: "‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Æ‡•Å‡§ù‡•á ‡§¶‡•Ç‡§ß ‡§ï‡§π‡§æ‡§Å ‡§Æ‡§ø‡§≤ ‡§∏‡§ï‡§§‡§æ ‡§π‡•àÔºü" ‚Üí Detect 'hi' ‚Üí Hindi response
10. Russian: "–ü—Ä–∏–≤–µ—Ç, –≥–¥–µ —è –º–æ–≥—É –Ω–∞–π—Ç–∏ –º–æ–ª–æ–∫–æÔºü" ‚Üí Detect 'ru' ‚Üí Russian response
11. Mixed: "Hello, ¬ød√≥nde est√° milk?" ‚Üí Detect primary language ‚Üí Respond in primary
```

**API Integration Tests**:
```
1. Network Test: POST /api/chat ‚Üí 200 status + proper JSON
2. Streaming Test: Response streams with typewriter effect
3. Error Test: Invalid input ‚Üí User-friendly error message
4. Performance Test: Response time <500ms for text queries
```

**Voice Recognition Tests**:
```
1. **Happy Path**: Voice recording ‚Üí OpenAI Whisper ‚Üí Accurate transcription ‚Üí Chat response
2. **Whisper Fallback**: Voice recording ‚Üí Whisper fails ‚Üí Web Speech API ‚Üí Transcription ‚Üí Chat response
3. **Complete Fallback**: Voice recording ‚Üí Whisper fails ‚Üí Web Speech "service-not-allowed" ‚Üí Manual input prompt
4. **Permission Denied**: Microphone blocked ‚Üí User-friendly error ‚Üí Text input alternative
5. **HTTPS Check**: Web Speech API on HTTP ‚Üí Proper error message ‚Üí Fallback to manual input
6. **Network Failure**: API timeout ‚Üí Graceful error handling ‚Üí Retry option
7. **Browser Support**: Safari MIME type ‚Üí Auto-detection ‚Üí Compatible format selection
8. **Language Test**: Spanish speech ‚Üí Whisper detects Spanish ‚Üí Spanish AI response
```

**UI/UX Tests**:
```
1. Mobile Responsive: Perfect experience on phone screens
2. Accessibility: Screen reader navigation works
3. Error States: Clear error messages with retry options
4. Loading States: Smooth loading indicators
5. No Language Selector: Zero manual language selection anywhere
```
</testing_scenarios>

<validation_checkpoints>
**VALIDATION CHECKPOINTS** (Check after each implementation):

**Checkpoint 1 - API Foundation**:
- [ ] /api/chat/route.ts exists and works
- [ ] Enhanced language detection function implemented (40+ languages)
- [ ] System prompt enforces same-language response with proper scripts
- [ ] OpenAI API key configured correctly with UTF-8 encoding
- [ ] JSON response structure correct
- [ ] Non-Latin scripts (Arabic, Chinese, etc.) detected properly

**Checkpoint 2 - Frontend Integration**:
- [ ] ChatInterface component renders properly
- [ ] User can type and send messages
- [ ] Streaming response with typewriter effect
- [ ] Language tags display on messages
- [ ] Error handling shows user-friendly messages

**Checkpoint 3 - Voice Processing**:
- [ ] AssemblyAI transcription working
- [ ] Web Speech API fallback implemented
- [ ] Microphone permission handling
- [ ] Voice input ‚Üí Text ‚Üí AI response flow complete
- [ ] Works across multiple languages

**Checkpoint 4 - Production Ready**:
- [ ] No manual language selection UI anywhere
- [ ] Mobile experience perfect
- [ ] Accessibility compliance verified
- [ ] Performance optimized
- [ ] Error handling comprehensive
</validation_checkpoints>

## üé® UI/UX SPECIFICATIONS

<design_requirements>
**Visual Design Standards**:
```css
/* Color Palette */
--primary: #28C6B1;        /* Teal accent */
--secondary: #F1F3F5;      /* Light gray */
--text-dark: #212529;      /* Dark text */  
--text-light: #F8F9FA;     /* Light text */
--error: #DC2626;          /* Error red */
--success: #10B981;        /* Success green */

/* Typography */
--font-primary: Inter, system-ui, sans-serif;
--font-size-base: 16px;
--line-height-base: 1.5;

/* Spacing Scale */
--space-xs: 4px;
--space-sm: 8px;
--space-md: 16px;
--space-lg: 24px;
--space-xl: 32px;

/* Animations */
--transition-fast: 150ms ease;
--transition-normal: 300ms ease;
--transition-slow: 500ms ease;
```
</design_requirements>

<component_specifications>
**Message Bubble Specifications**:
```tsx
// User Message Bubble
<div className="bg-[#28C6B1] text-white rounded-lg px-4 py-2 max-w-sm ml-auto">
  <div className="text-xs opacity-75 mb-1">EN</div>
  <div className="text-sm">{message}</div>
</div>

// Assistant Message Bubble  
<div className="bg-[#F1F3F5] text-gray-800 rounded-lg px-4 py-2 max-w-sm">
  <div className="text-xs text-gray-500 mb-1">ES</div>
  <div className="text-sm">{message}</div>
</div>
```

**Voice Interface Specifications**:
```tsx
// Voice Button (80px diameter, center of screen)
<button className="w-20 h-20 bg-[#28C6B1] rounded-full flex items-center justify-center animate-pulse">
  <MicIcon className="w-8 h-8 text-white" />
</button>

// Listening State
<div className="text-center">
  <div className="text-lg font-medium">Listening...</div>
  <div className="text-sm text-gray-600">Detected: ES</div>
</div>
```
</component_specifications>

## üöÄ PERFORMANCE & OPTIMIZATION

<performance_requirements>
**Performance Benchmarks**:
- First Load: <2 seconds on 3G
- Chat Response: <500ms text input to AI response start
- Voice Processing: <2 seconds speech to AI response start
- Streaming: 30ms per character for typewriter effect
- Memory Usage: <50MB total app footprint
- Bundle Size: <250KB gzipped JavaScript
</performance_requirements>

<optimization_strategies>
**Required Optimizations**:
1. **Code Splitting**: Lazy load voice components
2. **API Optimization**: Stream responses, don't wait for complete response
3. **Image Optimization**: Use Next.js Image component with proper sizing
4. **Caching**: Cache product catalog, implement proper HTTP caching
5. **Error Recovery**: Retry failed requests with exponential backoff
</optimization_strategies>

## üîê SECURITY & PRIVACY

<security_requirements>
**Security Standards**:
- API keys in environment variables (never in client code)
- Input validation on all user inputs
- XSS prevention with proper sanitization
- CSRF protection on API routes
- HTTPS enforcement in production
- Content Security Policy headers
</security_requirements>

<privacy_requirements>
**Privacy Standards**:
- No persistent storage of user conversations
- Voice data processed in real-time, not stored
- No tracking or analytics without consent
- Clear privacy policy for voice processing
- GDPR compliance for EU users
</privacy_requirements>

## üéØ SUCCESS METRICS & VALIDATION

<success_criteria>
**Technical Success Metrics**:
- ‚úÖ 100% of test cases pass
- ‚úÖ 95%+ language detection accuracy
- ‚úÖ <500ms average response time
- ‚úÖ Zero accessibility violations
- ‚úÖ Perfect mobile experience scores
- ‚úÖ No console errors in production

**User Experience Success Metrics**:
- ‚úÖ Users can complete shopping queries without confusion
- ‚úÖ Voice recognition works on first try 90%+ of time
- ‚úÖ Language switching seamless and automatic
- ‚úÖ Error recovery intuitive and helpful
- ‚úÖ Overall experience feels polished and professional
</success_criteria>

## üö® EMERGENCY PROTOCOLS

<emergency_debugging>
**When Implementation Fails**:

1. **API Connection Issues**:
```bash
# Test API directly
curl -X POST http://localhost:3000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "test"}' \
  -v
```

2. **Language Detection Issues**:
   - Add console.log to detectLanguage function
   - Test with known phrases in target languages
   - Verify system prompt includes detected language

3. **Voice Recognition Issues**:
   - Check browser console for microphone permission errors
   - Verify OpenAI Whisper API: `curl -X POST /api/speech -F "file=@test.wav"`
   - Test "service-not-allowed" error: Check HTTPS requirement for Web Speech API
   - Verify fallback chain: Whisper ‚Üí Web Speech ‚Üí Manual Input
   - Check audio format compatibility and MIME type fallbacks
   - Validate error handling shows user-friendly messages

4. **Performance Issues**:
   - Use React DevTools Profiler
   - Check Network tab for slow API calls
   - Monitor memory usage in dev tools
</emergency_debugging>

---

## üéØ IMPLEMENTATION PRIORITY ORDER

**Execute in this exact sequence:**

1. **FOUNDATION** (30 minutes): API route + language detection + system prompt
2. **INTEGRATION** (45 minutes): Chat UI + streaming + error handling  
3. **VOICE** (60 minutes): AssemblyAI + fallback + full voice flow
4. **POLISH** (30 minutes): Remove language selectors + final testing

**After each phase, validate against test cases before proceeding.**

Remember: This is not a learning exercise. This is production development. Every feature must work perfectly, handle all edge cases, and provide an exceptional user experience. No compromises, no shortcuts, no "good enough" solutions.

**Build it right. Build it complete. Build it now.** üöÄ